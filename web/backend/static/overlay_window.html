<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Projection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        body {
            background: black;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* Video container with transform capability */
        #video-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: center;
        }
        
        #bg-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Widget base styles */
        .widget {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            cursor: move;
            user-select: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: box-shadow 0.3s ease;
            overflow: visible;
        }
        
        /* Blackout overlay */
        #blackout-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: none;
        }
        
        #blackout-overlay.active {
            display: flex;
        }
        
        .light-switch {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .light-switch:hover {
            background: rgba(255, 255, 255, 0.1);
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        .light-switch svg {
            width: 24px;
            height: 24px;
            fill: rgba(255, 255, 255, 0.4);
        }
        
        .lights-widget {
            background: rgba(30, 30, 30, 0.85);
            min-width: 120px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .lights-widget:hover {
            background: rgba(40, 40, 40, 0.9);
        }
        
        .lights-widget .icon {
            width: 24px;
            height: 24px;
            fill: rgba(255, 255, 255, 0.5);
            margin-bottom: 4px;
        }
        
        .lights-widget .label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .lights-widget .widget-handle {
            display: none;
        }
        
        .widget:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        .widget.dragging {
            opacity: 0.8;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .widget-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border: 2px solid white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s;
            cursor: grab;
            z-index: 10;
        }
        
        .widget:hover .widget-handle {
            opacity: 1;
        }
        
        .widget-handle.rotate-handle {
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: #2196F3;
            cursor: crosshair;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .widget-handle.rotate-handle::after {
            content: '‚Üª';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: white;
            font-weight: bold;
        }
        
        .widget-handle.resize-se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }
        
        /* Widget specific styles */
        .weather-widget {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.9), rgba(42, 82, 152, 0.9));
        }
        
        .weather-widget h2 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 300;
        }
        
        .weather-content {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .weather-icon {
            font-size: 64px;
        }
        
        .weather-details {
            flex: 1;
        }
        
        .temperature {
            font-size: 48px;
            font-weight: 300;
            line-height: 1;
        }
        
        .weather-description {
            font-size: 18px;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .weather-location {
            font-size: 16px;
            opacity: 0.8;
            margin-top: 10px;
        }
        
        .time-widget {
            background: linear-gradient(135deg, rgba(38, 50, 56, 0.9), rgba(55, 71, 79, 0.9));
            text-align: center;
        }
        
        .time-content {
            font-size: 48px;
            font-weight: 300;
            letter-spacing: 2px;
            margin: 10px 0;
        }
        
        .date-content {
            font-size: 18px;
            opacity: 0.9;
        }
        
        .transit-widget {
            background: #0a0a0a;
            border: 3px solid #333;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }
        
        .transit-widget h2 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 300;
            color: #ffcc00;
            text-align: center;
            text-transform: uppercase;
        }
        
        .transit-content {
            font-size: 18px;
            line-height: 1.6;
        }
        
        .transit-content .prediction {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .transit-content .prediction:last-child {
            border-bottom: none;
        }
        
        .transit-content .prediction-route {
            flex: 1;
            font-weight: 500;
        }
        
        .transit-content .prediction-time {
            color: #ffcc00;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }
        
        .transit-content .no-service {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
            padding: 20px 0;
        }
        
        /* Split-flap display styles */
        .split-flap-display {
            padding: 10px;
        }
        
        .split-flap-row {
            display: flex;
            margin: 10px 0;
            align-items: center;
            gap: 20px;
        }
        
        .flap-section {
            display: flex;
            gap: 2px;
        }
        
        .flap-char {
            display: inline-block;
            width: 30px;
            height: 45px;
            position: relative;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #ffcc00;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            line-height: 45px;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            text-transform: uppercase;
        }
        
        /* Route section - larger and green */
        .route-section .flap-char {
            color: #00ff00;
            font-size: 32px;
            width: 35px;
            height: 50px;
            line-height: 50px;
            text-shadow: 0 0 5px currentColor;
        }
        
        /* Time section - red for urgency */
        .time-section .flap-char {
            color: #ff3333;
            text-shadow: 0 0 5px currentColor;
        }
        
        /* Destination section */
        .destination-section .flap-char {
            width: 25px;
            height: 40px;
            font-size: 24px;
            line-height: 40px;
        }
        
        /* Active flipping state */
        .flap-char.flipping-active {
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        
        /* Single flip animation */
        .flap-char.flip {
            animation: splitFlap 0.1s ease-out;
        }
        
        @keyframes splitFlap {
            0% {
                transform: rotateX(0deg);
                background: #1a1a1a;
            }
            50% {
                transform: rotateX(-90deg);
                background: #000;
                color: transparent;
            }
            100% {
                transform: rotateX(0deg);
                background: #1a1a1a;
            }
        }
        
        /* Blur during rapid flipping */
        .flap-char.flipping-active:not(.flip) {
            filter: blur(0.8px);
        }
        
        /* Section labels */
        .section-label {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            margin-right: 10px;
            width: 60px;
            text-align: right;
        }
        
        /* Control panel */
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls.hidden {
            display: none;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 500;
            color: #4CAF50;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group input[type="number"] {
            width: 60px;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 5px;
            border-radius: 4px;
        }
        
        .control-value {
            font-size: 12px;
            opacity: 0.7;
            text-align: right;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .shortcuts {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            opacity: 0.7;
            line-height: 1.8;
        }
        
        /* Loading spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
        }
        
        /* Error state */
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5252;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading projection...</div>
    
    <div id="video-container">
        <video id="bg-video" autoplay loop muted playsinline>
            <source id="video-source" type="video/mp4"/>
            Your browser does not support the video tag.
        </video>
    </div>
    
    <div id="widgets-container"></div>
    
    <div id="blackout-overlay">
        <div class="light-switch" onclick="toggleLights()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M12 18c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-15c-3.312 0-6 2.688-6 6 0 1.408.486 2.701 1.297 3.719l4.703 5.881 4.703-5.881C17.514 11.701 18 10.408 18 9c0-3.312-2.688-6-6-6z"/>
            </svg>
        </div>
    </div>
    
    <div id="brightness-overlay" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: black;
        pointer-events: none;
        z-index: 9998;
        opacity: 0;
        transition: opacity 0.3s ease;
    "></div>
    
    <div class="controls" id="controls">
        <h2 style="margin-bottom: 20px; font-weight: 300;">Overlay Controls</h2>
        
        <div class="control-group">
            <h3>Video Transform</h3>
            <label>X Position: <span class="control-value" id="video-x-value">0</span></label>
            <input type="range" id="video-x" min="-500" max="500" value="0">
            
            <label>Y Position: <span class="control-value" id="video-y-value">0</span></label>
            <input type="range" id="video-y" min="-500" max="500" value="0">
            
            <label>Scale: <span class="control-value" id="video-scale-value">1</span></label>
            <input type="range" id="video-scale" min="0.5" max="2" step="0.1" value="1">
            
            <label>Rotation: <span class="control-value" id="video-rotation-value">0</span>¬∞</label>
            <input type="range" id="video-rotation" min="-180" max="180" value="0">
        </div>
        
        <div class="control-group">
            <h3>Widget Visibility</h3>
            <div id="widget-visibility-controls"></div>
        </div>
        
        <div class="control-group" id="transit-settings" style="display: none;">
            <h3>Transit Display Settings</h3>
            <label style="display: flex; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" id="transit-splitflap" onchange="toggleTransitDisplay(this.checked)" style="margin-right: 8px;">
                Split-Flap Display (Classic Board Style)
            </label>
            <label>Animation Speed</label>
            <select id="transit-flip-speed" onchange="updateFlipSpeed(this.value)" style="width: 100%; padding: 5px; background: #333; border: 1px solid #555; color: white; border-radius: 4px;">
                <option value="slow">Slow</option>
                <option value="normal" selected>Normal</option>
                <option value="fast">Fast</option>
            </select>
        </div>
        
        <div class="control-group">
            <button onclick="saveConfig(this)">üíæ Save Configuration</button>
            <button onclick="resetTransforms()">üîÑ Reset All</button>
            <button onclick="toggleControls()">üëÅÔ∏è Hide Controls</button>
        </div>
        
        <div class="control-group">
            <h3>Config Import/Export</h3>
            <button onclick="exportConfig()">üì§ Export to File</button>
            <button onclick="document.getElementById('import-file').click()">üì• Import from File</button>
            <input type="file" id="import-file" accept=".json" style="display: none;" onchange="importConfig(event)">
        </div>
        
        <div class="shortcuts">
            <strong>Keyboard Shortcuts:</strong><br>
            H: Hide/show controls<br>
            S: Save configuration<br>
            R: Reset transforms<br>
            Arrow Keys: Move selected widget<br>
            +/-: Scale selected widget<br>
            F11: Fullscreen
        </div>
    </div>
    
    <script>
        let config = null;
        let videoTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
        let widgets = [];
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let currentWidget = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStart = { width: 0, height: 0, x: 0, y: 0 };
        let rotateStart = { angle: 0, mouseAngle: 0 };
        let selectedWidget = null;
        let dataUpdateIntervals = {};
        
        // Initialize from parent window
        window.addEventListener('message', function(event) {
            if (event.data.type === 'init') {
                config = event.data.config;
                videoTransform = config.video_transform || { x: 0, y: 0, scale: 1, rotation: 0 };
                widgets = config.widgets;
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Load video with retry logic
                loadVideoWithRetry(event.data.streamingUrl);
                
                // Apply transforms
                updateVideoTransform();
                
                // Update control values to match loaded config
                document.getElementById('video-x').value = videoTransform.x;
                document.getElementById('video-x-value').textContent = videoTransform.x;
                document.getElementById('video-y').value = videoTransform.y;
                document.getElementById('video-y-value').textContent = videoTransform.y;
                document.getElementById('video-scale').value = videoTransform.scale;
                document.getElementById('video-scale-value').textContent = videoTransform.scale;
                document.getElementById('video-rotation').value = videoTransform.rotation;
                document.getElementById('video-rotation-value').textContent = videoTransform.rotation;
                
                // Create widgets
                createWidgets();
                
                // Create visibility controls
                createVisibilityControls();
                
                // Start data updates
                startDataUpdates();
                
                // Start combined status polling for brightness and sync
                startOverlayStatusPolling();
            }
        });
        
        function loadVideoWithRetry(streamingUrl) {
            const video = document.getElementById('bg-video');
            const source = document.getElementById('video-source');
            
            console.log('Loading video from streaming URL:', streamingUrl);
            
            // Use the URL directly from backend
            source.src = streamingUrl;
            video.load();
            
            video.onerror = () => {
                console.error('Failed to load video from:', streamingUrl);
                showError('Unable to load video stream. Please check the streaming server is running and the video path is correct.');
            };
            
            video.oncanplay = () => {
                console.log('Video loaded successfully from:', streamingUrl);
            };
        }
        
        function showError(message) {
            const error = document.createElement('div');
            error.className = 'error';
            error.innerHTML = `<h3>Error</h3><p>${message}</p>`;
            document.body.appendChild(error);
        }
        
        function updateVideoTransform() {
            const container = document.getElementById('video-container');
            container.style.transform = `
                translate(${videoTransform.x}px, ${videoTransform.y}px)
                scale(${videoTransform.scale})
                rotate(${videoTransform.rotation}deg)
            `;
        }
        
        function createWidgets() {
            const container = document.getElementById('widgets-container');
            container.innerHTML = '';
            
            widgets.forEach(widget => {
                if (!widget.visible) return;
                
                const widgetEl = document.createElement('div');
                widgetEl.className = `widget ${widget.type}-widget`;
                widgetEl.id = widget.id;
                widgetEl.style.left = widget.position.x + 'px';
                widgetEl.style.top = widget.position.y + 'px';
                widgetEl.style.width = widget.size.width + 'px';
                widgetEl.style.height = widget.size.height + 'px';
                widgetEl.style.transform = `rotate(${widget.rotation || 0}deg)`;
                
                // Add content based on type
                if (widget.type === 'weather') {
                    widgetEl.innerHTML = `
                        <h2>Weather</h2>
                        <div class="weather-content">
                            <div class="weather-icon">‚òÄÔ∏è</div>
                            <div class="weather-details">
                                <div class="temperature">--¬∞</div>
                                <div class="weather-description">Loading...</div>
                                <div class="weather-location">--</div>
                            </div>
                        </div>
                    `;
                } else if (widget.type === 'time') {
                    widgetEl.innerHTML = `
                        <div class="time-content">00:00:00</div>
                        <div class="date-content">Loading...</div>
                    `;
                } else if (widget.type === 'transit') {
                    const displayStyle = widget.config.displayStyle || 'simple';
                    
                    if (displayStyle === 'splitFlap') {
                        widgetEl.innerHTML = `
                            <div class="transit-content split-flap-display" data-stop-name="${widget.config.stopName || 'Nearby Stop'}">
                                <div class="initializing">Initializing display...</div>
                            </div>
                        `;
                    } else {
                        widgetEl.innerHTML = `
                            <h2>Transit - ${widget.config.stopName || 'Nearby Stop'}</h2>
                            <div class="transit-content">Loading predictions...</div>
                        `;
                    }
                } else if (widget.type === 'lights') {
                    widgetEl.innerHTML = `
                        <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M6 2l.01 6L10 12l-4 2.01L6.01 20C8.77 21.31 11.31 22 14 22c6.63 0 12-5.37 12-12S20.63-2 14-2C11.31-2 8.77-1.31 6 0v2z"/>
                            </svg>
                            <div class="label">Lights</div>
                        </div>
                    `;
                    widgetEl.classList.add('lights-widget');
                    widgetEl.onclick = (e) => {
                        e.stopPropagation();
                        toggleLights();
                    };
                }
                
                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'widget-handle resize-se';
                widgetEl.appendChild(resizeHandle);
                
                // Add rotation handle (except for lights widget)
                if (widget.type !== 'lights') {
                    const rotateHandle = document.createElement('div');
                    rotateHandle.className = 'widget-handle rotate-handle';
                    rotateHandle.title = 'Drag to rotate';
                    widgetEl.appendChild(rotateHandle);
                    
                    // Add event handler directly here
                    rotateHandle.addEventListener('mousedown', startRotate);
                }
                
                // Add event handlers
                widgetEl.addEventListener('mousedown', startDrag);
                resizeHandle.addEventListener('mousedown', startResize);
                widgetEl.addEventListener('click', () => selectWidget(widget.id));
                
                container.appendChild(widgetEl);
            });
        }
        
        function createVisibilityControls() {
            const container = document.getElementById('widget-visibility-controls');
            container.innerHTML = '';
            
            let hasTransitWidget = false;
            
            widgets.forEach(widget => {
                const control = document.createElement('label');
                control.style.display = 'block';
                control.style.marginBottom = '5px';
                
                // Custom label for lights widget
                const widgetLabel = widget.type === 'lights' ? 'Lights Control' : 
                                   widget.type.charAt(0).toUpperCase() + widget.type.slice(1);
                
                control.innerHTML = `
                    <input type="checkbox" ${widget.visible ? 'checked' : ''} 
                           onchange="toggleWidgetVisibility('${widget.id}', this.checked)">
                    ${widgetLabel}
                `;
                container.appendChild(control);
                
                if (widget.type === 'transit') {
                    hasTransitWidget = true;
                }
            });
            
            // Show/hide transit settings based on widget presence
            const transitSettings = document.getElementById('transit-settings');
            if (transitSettings) {
                transitSettings.style.display = hasTransitWidget ? 'block' : 'none';
                
                // Set checkbox state if we have transit widgets
                if (hasTransitWidget) {
                    const transitWidget = widgets.find(w => w.type === 'transit');
                    const splitFlapCheckbox = document.getElementById('transit-splitflap');
                    if (splitFlapCheckbox && transitWidget) {
                        splitFlapCheckbox.checked = transitWidget.config.displayStyle === 'splitFlap';
                    }
                }
            }
        }
        
        function toggleWidgetVisibility(widgetId, visible) {
            const widget = widgets.find(w => w.id === widgetId);
            if (widget) {
                widget.visible = visible;
                createWidgets();
                if (visible) {
                    startDataUpdates();
                }
            }
        }
        
        function selectWidget(widgetId) {
            selectedWidget = widgetId;
            document.querySelectorAll('.widget').forEach(w => {
                w.style.border = w.id === widgetId ? '2px solid #4CAF50' : '1px solid rgba(255, 255, 255, 0.1)';
            });
            
            // Update rotation display if we have one
            const widget = widgets.find(w => w.id === widgetId);
            if (widget && window.updateSelectedWidgetInfo) {
                window.updateSelectedWidgetInfo(widget);
            }
        }
        
        function startDrag(e) {
            if (e.target.classList.contains('widget-handle')) return;
            
            isDragging = true;
            currentWidget = e.currentTarget;
            currentWidget.classList.add('dragging');
            
            const rect = currentWidget.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            selectWidget(currentWidget.id);
            e.preventDefault();
        }
        
        function startResize(e) {
            e.stopPropagation();
            isResizing = true;
            currentWidget = e.target.parentElement;
            
            const rect = currentWidget.getBoundingClientRect();
            resizeStart = {
                width: rect.width,
                height: rect.height,
                x: e.clientX,
                y: e.clientY
            };
            
            e.preventDefault();
        }
        
        function startRotate(e) {
            e.stopPropagation();
            isRotating = true;
            currentWidget = e.target.parentElement;
            
            const rect = currentWidget.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Get current rotation
            const widget = widgets.find(w => w.id === currentWidget.id);
            const currentRotation = widget.rotation || 0;
            
            // Calculate initial mouse angle
            const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
            
            rotateStart = {
                angle: currentRotation,
                mouseAngle: mouseAngle
            };
            
            e.preventDefault();
        }
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging && currentWidget) {
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                currentWidget.style.left = x + 'px';
                currentWidget.style.top = y + 'px';
                
                // Update widget position in config
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.position.x = x;
                    widget.position.y = y;
                }
            } else if (isResizing && currentWidget) {
                const deltaX = e.clientX - resizeStart.x;
                const deltaY = e.clientY - resizeStart.y;
                
                const newWidth = Math.max(200, resizeStart.width + deltaX);
                const newHeight = Math.max(100, resizeStart.height + deltaY);
                
                currentWidget.style.width = newWidth + 'px';
                currentWidget.style.height = newHeight + 'px';
                
                // Update widget size in config
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.size.width = newWidth;
                    widget.size.height = newHeight;
                }
            } else if (isRotating && currentWidget) {
                const rect = currentWidget.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Calculate current mouse angle
                const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                
                // Calculate rotation delta
                const angleDelta = currentMouseAngle - rotateStart.mouseAngle;
                let newRotation = rotateStart.angle + angleDelta;
                
                // Normalize angle to 0-360
                newRotation = ((newRotation % 360) + 360) % 360;
                
                // Apply rotation
                currentWidget.style.transform = `rotate(${newRotation}deg)`;
                
                // Update widget data
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.rotation = newRotation;
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (currentWidget) {
                currentWidget.classList.remove('dragging');
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
            currentWidget = null;
        });
        
        // Keyboard controls for fine rotation
        document.addEventListener('keydown', (e) => {
            if (selectedWidget && !e.target.matches('input')) {
                const widget = widgets.find(w => w.id === selectedWidget);
                if (!widget) return;
                
                let rotationDelta = 0;
                
                // Shift + Left/Right for rotation
                if (e.shiftKey) {
                    if (e.key === 'ArrowLeft') {
                        rotationDelta = -5;
                    } else if (e.key === 'ArrowRight') {
                        rotationDelta = 5;
                    }
                    
                    if (rotationDelta !== 0) {
                        e.preventDefault();
                        widget.rotation = ((widget.rotation || 0) + rotationDelta + 360) % 360;
                        const widgetEl = document.getElementById(widget.id);
                        if (widgetEl) {
                            widgetEl.style.transform = `rotate(${widget.rotation}deg)`;
                        }
                    }
                }
            }
        });
        
        // Video transform controls
        document.getElementById('video-x').addEventListener('input', (e) => {
            videoTransform.x = parseFloat(e.target.value);
            document.getElementById('video-x-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-y').addEventListener('input', (e) => {
            videoTransform.y = parseFloat(e.target.value);
            document.getElementById('video-y-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-scale').addEventListener('input', (e) => {
            videoTransform.scale = parseFloat(e.target.value);
            document.getElementById('video-scale-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-rotation').addEventListener('input', (e) => {
            videoTransform.rotation = parseFloat(e.target.value);
            document.getElementById('video-rotation-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        // Removed addLightsWidget function - lights widget is now added through React frontend
        
        // Combined status polling for brightness and sync
        function startOverlayStatusPolling() {
            let lastSyncEventId = null;
            let eventSource = null;
            let reconnectTimeout = null;
            
            function connectEventSource() {
                if (eventSource) {
                    eventSource.close();
                }
                
                console.log('Connecting to overlay events stream...');
                eventSource = new EventSource('/api/overlay/events');
                
                eventSource.onopen = () => {
                    console.log('Connected to overlay events stream');
                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }
                };
                
                eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // Handle initialization or brightness updates
                        if (data.type === 'init' || data.type === 'brightness') {
                            const brightness = data.type === 'init' ? data.data.brightness : data.data.brightness;
                            const opacity = (100 - brightness) / 100;
                            document.getElementById('brightness-overlay').style.opacity = opacity;
                            
                            // Initialize sync state from init event
                            if (data.type === 'init' && data.data.sync && data.data.sync.event_id) {
                                lastSyncEventId = data.data.sync.event_id;
                            }
                        }
                        
                        // Handle sync events
                        if (data.type === 'sync' && data.data.event_id !== lastSyncEventId) {
                            lastSyncEventId = data.data.event_id;
                            console.log(`Sync event detected: ${data.data.triggered_by} at ${data.data.timestamp}`);
                            
                            // Sync video playback
                            const video = document.getElementById('bg-video');
                            const syncStartTime = performance.now();
                            
                            video.currentTime = 0;
                            video.play().then(() => {
                                const syncTime = performance.now() - syncStartTime;
                                console.log(`Video synced in ${syncTime}ms`);
                            }).catch(err => {
                                console.error('Failed to sync video:', err);
                            });
                        }
                    } catch (error) {
                        console.error('Error processing event:', error);
                    }
                };
                
                eventSource.onerror = (error) => {
                    console.error('EventSource error:', error);
                    eventSource.close();
                    
                    // Reconnect after delay
                    if (!reconnectTimeout) {
                        reconnectTimeout = setTimeout(() => {
                            console.log('Attempting to reconnect...');
                            connectEventSource();
                        }, 5000);
                    }
                };
            }
            
            // Start connection
            connectEventSource();
            
            // Fallback polling (only if EventSource is not supported)
            if (!window.EventSource) {
                console.warn('EventSource not supported, falling back to polling');
                // Original polling code here as fallback
                async function updateOverlayStatus() {
                    try {
                        const response = await fetch('/api/overlay/status');
                        const status = await response.json();
                        
                        const opacity = (100 - status.brightness) / 100;
                        document.getElementById('brightness-overlay').style.opacity = opacity;
                        
                        if (status.sync && status.sync.event_id && status.sync.event_id !== lastSyncEventId) {
                            lastSyncEventId = status.sync.event_id;
                            console.log(`Sync event detected: ${status.sync.triggered_by} at ${status.sync.timestamp}`);
                            
                            const video = document.getElementById('bg-video');
                            video.currentTime = 0;
                            video.play().catch(err => {
                                console.error('Failed to sync video:', err);
                            });
                        }
                    } catch (error) {
                        console.error('Status update error:', error);
                    }
                }
                
                setInterval(updateOverlayStatus, 5000); // Reduced frequency for fallback
            }
        }
        
        // Lights toggle function - updated to use brightness API
        async function toggleLights() {
            try {
                // Get current brightness
                const response = await fetch('/api/overlay/brightness');
                const data = await response.json();
                
                // Toggle between 0 and 100
                const newBrightness = data.brightness > 50 ? 0 : 100;
                
                await fetch('/api/overlay/brightness?brightness=' + newBrightness, {
                    method: 'POST'
                });
                
                // Update controls visibility based on brightness
                const controls = document.getElementById('controls');
                if (newBrightness === 0) {
                    controls.style.display = 'none';
                } else {
                    controls.style.display = 'block';
                }
            } catch (error) {
                console.error('Toggle lights error:', error);
                // Fallback to original behavior
                const blackout = document.getElementById('blackout-overlay');
                const controls = document.getElementById('controls');
                
                if (blackout.classList.contains('active')) {
                    blackout.classList.remove('active');
                    controls.style.display = 'block';
                } else {
                    blackout.classList.add('active');
                    controls.style.display = 'none';
                }
            }
        }
        
        // Control functions
        function saveConfig(button) {
            if (!config) return;
            
            config.video_transform = videoTransform;
            config.widgets = widgets;
            
            if (window.opener && !window.opener.closed) {
                window.opener.postMessage({
                    type: 'updateConfig',
                    config: config
                }, '*');
                
                // Visual feedback
                if (button) {
                    button.textContent = '‚úÖ Saved!';
                    setTimeout(() => {
                        button.textContent = 'üíæ Save Configuration';
                    }, 2000);
                }
            }
        }
        
        function resetTransforms() {
            videoTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
            
            // Reset controls
            document.getElementById('video-x').value = 0;
            document.getElementById('video-x-value').textContent = '0';
            document.getElementById('video-y').value = 0;
            document.getElementById('video-y-value').textContent = '0';
            document.getElementById('video-scale').value = 1;
            document.getElementById('video-scale-value').textContent = '1';
            document.getElementById('video-rotation').value = 0;
            document.getElementById('video-rotation-value').textContent = '0';
            
            updateVideoTransform();
        }
        
        function toggleControls() {
            document.getElementById('controls').classList.toggle('hidden');
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const step = e.shiftKey ? 10 : 1;
            
            if (e.key === 'h' || e.key === 'H') {
                toggleControls();
            } else if (e.key === 's' || e.key === 'S') {
                saveConfig(null);
            } else if (e.key === 'r' || e.key === 'R') {
                resetTransforms();
            } else if (e.key === 'F11') {
                e.preventDefault();
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            } else if (selectedWidget) {
                // Widget movement with arrow keys
                const widget = widgets.find(w => w.id === selectedWidget);
                const widgetEl = document.getElementById(selectedWidget);
                
                if (widget && widgetEl) {
                    switch(e.key) {
                        case 'ArrowLeft':
                            widget.position.x -= step;
                            widgetEl.style.left = widget.position.x + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            widget.position.x += step;
                            widgetEl.style.left = widget.position.x + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowUp':
                            widget.position.y -= step;
                            widgetEl.style.top = widget.position.y + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            widget.position.y += step;
                            widgetEl.style.top = widget.position.y + 'px';
                            e.preventDefault();
                            break;
                    }
                }
            }
        });
        
        // Data update functions
        function startDataUpdates() {
            // Clear existing intervals
            Object.values(dataUpdateIntervals).forEach(interval => clearInterval(interval));
            dataUpdateIntervals = {};
            
            // Update time immediately and every second
            updateTime();
            dataUpdateIntervals.time = setInterval(updateTime, 1000);
            
            // Update weather immediately and every 5 minutes
            updateWeather();
            dataUpdateIntervals.weather = setInterval(updateWeather, 300000);
            
            // Update transit immediately and every minute
            updateTransit();
            dataUpdateIntervals.transit = setInterval(updateTransit, 60000);
        }
        
        function updateTime() {
            const timeWidgets = document.querySelectorAll('.time-widget');
            const now = new Date();
            
            // Convert to PST
            const pstTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
            
            const timeString = pstTime.toLocaleTimeString('en-US', { 
                hour12: true,
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit'
            });
            
            const dateString = pstTime.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            timeWidgets.forEach(widget => {
                const timeEl = widget.querySelector('.time-content');
                const dateEl = widget.querySelector('.date-content');
                if (timeEl) timeEl.textContent = timeString + ' PST';
                if (dateEl) dateEl.textContent = dateString;
            });
        }
        
        async function updateWeather() {
            if (!config?.api_configs?.weather_api_key) {
                console.warn('No weather API key configured');
                return;
            }
            
            const weatherWidgets = document.querySelectorAll('.weather-widget');
            if (weatherWidgets.length === 0) return;
            
            try {
                // Get location
                const locationResponse = await fetch('https://ipinfo.io/json');
                const locationData = await locationResponse.json();
                const city = locationData.city || 'San Francisco';
                
                // Get weather
                const weatherResponse = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${config.api_configs.weather_api_key}&units=imperial`
                );
                const weatherData = await weatherResponse.json();
                
                // Map weather conditions to emojis
                const weatherIcons = {
                    'Clear': '‚òÄÔ∏è',
                    'Clouds': '‚òÅÔ∏è',
                    'Rain': 'üåßÔ∏è',
                    'Drizzle': 'üå¶Ô∏è',
                    'Thunderstorm': '‚õàÔ∏è',
                    'Snow': '‚ùÑÔ∏è',
                    'Mist': 'üå´Ô∏è',
                    'Fog': 'üå´Ô∏è'
                };
                
                const icon = weatherIcons[weatherData.weather[0].main] || 'üå°Ô∏è';
                const temp = Math.round(weatherData.main.temp);
                const description = weatherData.weather[0].description;
                const location = weatherData.name;
                
                weatherWidgets.forEach(widget => {
                    widget.querySelector('.weather-icon').textContent = icon;
                    widget.querySelector('.temperature').textContent = `${temp}¬∞F`;
                    widget.querySelector('.weather-description').textContent = description;
                    widget.querySelector('.weather-location').textContent = location;
                });
            } catch (error) {
                console.error('Weather update error:', error);
                weatherWidgets.forEach(widget => {
                    widget.querySelector('.weather-description').textContent = 'Weather unavailable';
                });
            }
        }
        
        async function updateTransit() {
            if (!config?.api_configs?.transit_stop_id) {
                console.warn('No transit stop ID configured');
                return;
            }
            
            const transitWidgets = document.querySelectorAll('.transit-widget');
            if (transitWidgets.length === 0) return;
            
            try {
                const response = await fetch(
                    `https://webservices.umoiq.com/api/pub/v1/agencies/sfmta-cis/stopcodes/${config.api_configs.transit_stop_id}/predictions?key=0be8ebd0284ce712a63f29dcaf7798c4`
                );
                const data = await response.json();
                
                transitWidgets.forEach(widget => {
                    const widgetConfig = widgets.find(w => w.id === widget.id);
                    const routeFilter = widgetConfig?.config?.routeFilter?.toLowerCase();
                    
                    // Collect all predictions with valid times
                    let allPredictions = [];
                    
                    data.forEach(routeData => {
                        if (routeData.values && routeData.values.length > 0) {
                            // Add each prediction with route info
                            routeData.values.forEach(value => {
                                if (value.minutes !== undefined && value.minutes !== null) {
                                    allPredictions.push({
                                        route: routeData.route,
                                        minutes: value.minutes,
                                        direction: value.direction,
                                        vehicleId: value.vehicleId
                                    });
                                }
                            });
                        }
                    });
                    
                    // Sort by minutes
                    allPredictions.sort((a, b) => a.minutes - b.minutes);
                    
                    // Apply route filter if specified
                    let filteredPredictions = allPredictions;
                    if (routeFilter) {
                        // First try exact match
                        filteredPredictions = allPredictions.filter(p => 
                            p.route.title.toLowerCase().includes(routeFilter)
                        );
                        
                        // If no exact matches and it's late night, include Night Owl
                        if (filteredPredictions.length === 0) {
                            const hour = new Date().getHours();
                            // Between 11 PM and 5 AM, show Night Owl service
                            if (hour >= 23 || hour <= 5) {
                                filteredPredictions = allPredictions.filter(p => 
                                    p.route.id.includes('NOWL') || p.route.id.includes('OWL')
                                );
                            }
                        }
                        
                        // If still no predictions, show all available
                        if (filteredPredictions.length === 0) {
                            filteredPredictions = allPredictions;
                        }
                    }
                    
                    const content = widget.querySelector('.transit-content');
                    const widgetEl = document.getElementById(widget.id);
                    
                    if (filteredPredictions.length === 0) {
                        const hour = new Date().getHours();
                        const message = (hour >= 1 && hour <= 5) 
                            ? 'No service until morning' 
                            : 'No predictions available';
                        content.innerHTML = `<div class="no-service">${message}</div>`;
                        return;
                    }
                    
                    // Check if this is a split-flap display
                    if (widgetConfig?.displayStyle === 'splitFlap' || content.classList.contains('split-flap-display')) {
                        // Convert back to original format for split-flap display
                        const formattedPredictions = filteredPredictions.slice(0, 3).map(p => ({
                            route: p.route,
                            values: [{ minutes: p.minutes }]
                        }));
                        updateSplitFlapDisplay(content, formattedPredictions);
                    } else {
                        // Show simple display up to 3 predictions
                        const html = filteredPredictions.slice(0, 3).map(prediction => {
                            const routeName = prediction.route.title;
                            const isNightOwl = prediction.route.id.includes('NOWL') || prediction.route.id.includes('OWL');
                            const displayName = isNightOwl ? `${routeName} üåô` : routeName;
                            
                            return `
                                <div class="prediction">
                                    <span class="prediction-route">${displayName}</span>
                                    <span class="prediction-time">${prediction.minutes} min</span>
                                </div>
                            `;
                        }).join('');
                        
                        content.innerHTML = html;
                    }
                });
            } catch (error) {
                console.error('Transit update error:', error);
                transitWidgets.forEach(widget => {
                    widget.querySelector('.transit-content').innerHTML = 'Transit data unavailable';
                });
            }
        }
        
        // Split-flap display functions
        const FLAP_CHARS = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-:';
        let flipSpeed = 'normal';
        
        function toggleTransitDisplay(useSplitFlap) {
            widgets.forEach(widget => {
                if (widget.type === 'transit') {
                    widget.config.displayStyle = useSplitFlap ? 'splitFlap' : 'simple';
                }
            });
            createWidgets();
            startDataUpdates();
        }
        
        function updateFlipSpeed(speed) {
            flipSpeed = speed;
            widgets.forEach(widget => {
                if (widget.type === 'transit' && widget.config.displayStyle === 'splitFlap') {
                    widget.config.flipSpeed = speed;
                }
            });
        }
        
        function createSplitFlapDisplay(predictions, stopName) {
            // Create header row with animated title
            const headerText = `TRANSIT - ${stopName.toUpperCase()}`.padEnd(24, ' ');
            let html = `
                <div class="split-flap-row header-row">
                    <div class="flap-section header-section">
                        ${headerText.split('').map((char, i) => 
                            `<div class="flap-char" data-current="${char}" data-position="header-${i}">${char}</div>`
                        ).join('')}
                    </div>
                </div>
            `;
            
            // Add prediction rows
            html += predictions.slice(0, 3).map((prediction, index) => {
                const routeChars = prediction.route.title.toUpperCase().substring(0, 4).padEnd(4, ' ');
                const minutesStr = String(prediction.values[0]?.minutes || 0).padStart(2, '0');
                
                return `
                    <div class="split-flap-row" data-index="${index}">
                        <div class="flap-section route-section">
                            ${routeChars.split('').map((char, i) => 
                                `<div class="flap-char" data-current="${char}" data-position="route-${i}">${char}</div>`
                            ).join('')}
                        </div>
                        <div class="flap-section destination-section">
                            ${prediction.route.title.toUpperCase().substring(0, 12).padEnd(12, ' ').split('').map((char, i) => 
                                `<div class="flap-char" data-current="${char}" data-position="dest-${i}">${char}</div>`
                            ).join('')}
                        </div>
                        <div class="flap-section time-section">
                            ${minutesStr.split('').map((char, i) => 
                                `<div class="flap-char" data-current="${char}" data-position="time-${i}">${char}</div>`
                            ).join('')}
                            <div class="flap-char" data-current=" " data-position="space"> </div>
                            <div class="flap-char" data-current="M" data-position="m">M</div>
                            <div class="flap-char" data-current="I" data-position="i">I</div>
                            <div class="flap-char" data-current="N" data-position="n">N</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            return html;
        }
        
        async function updateSplitFlapDisplay(container, predictions) {
            const currentHTML = container.innerHTML;
            const stopName = container.dataset.stopName || 'Nearby Stop';
            
            // If empty, create initial display
            if (!container.querySelector('.split-flap-row')) {
                container.innerHTML = createSplitFlapDisplay(predictions, stopName);
                return;
            }
            
            // Update existing display with animations
            const rows = container.querySelectorAll('.split-flap-row');
            
            // Animate header row
            const headerRow = container.querySelector('.header-row');
            if (headerRow) {
                const headerText = `TRANSIT - ${stopName.toUpperCase()}`.padEnd(24, ' ');
                const headerFlaps = headerRow.querySelectorAll('.flap-char');
                animateFlaps(headerFlaps, headerText, true);
            }
            
            // Animate prediction rows
            const predictionRows = container.querySelectorAll('.split-flap-row:not(.header-row)');
            for (let i = 0; i < Math.min(predictions.length, 3); i++) {
                const prediction = predictions[i];
                const row = predictionRows[i];
                if (!row) continue;
                
                // Update route - force animate all characters
                const routeChars = prediction.route.title.toUpperCase().substring(0, 4).padEnd(4, ' ');
                const routeFlaps = row.querySelectorAll('.route-section .flap-char');
                animateFlaps(routeFlaps, routeChars, true);
                
                // Update destination - force animate all characters
                const destChars = prediction.route.title.toUpperCase().substring(0, 12).padEnd(12, ' ');
                const destFlaps = row.querySelectorAll('.destination-section .flap-char');
                animateFlaps(destFlaps, destChars, true);
                
                // Update time - animate all characters including " MIN"
                const minutesStr = String(prediction.values[0]?.minutes || 0).padStart(2, '0');
                const timeStr = minutesStr + ' MIN';
                const timeFlaps = row.querySelectorAll('.time-section .flap-char');
                animateFlaps(timeFlaps, timeStr, true);
            }
        }
        
        async function animateFlaps(flaps, targetString, forceAnimate = false) {
            const promises = [];
            for (let i = 0; i < flaps.length && i < targetString.length; i++) {
                const flap = flaps[i];
                const targetChar = targetString[i].toUpperCase();
                promises.push(flipToChar(flap, targetChar, forceAnimate));
            }
            await Promise.all(promises);
        }
        
        async function flipToChar(element, targetChar, forceAnimate = false) {
            const currentChar = element.dataset.current || ' ';
            if (!forceAnimate && currentChar === targetChar) return;
            
            const sequence = getFlipSequence(currentChar, targetChar);
            element.classList.add('flipping-active');
            
            const baseDelay = flipSpeed === 'slow' ? 100 : flipSpeed === 'fast' ? 30 : 50;
            
            for (let i = 0; i < sequence.length; i++) {
                const char = sequence[i];
                const isLast = i === sequence.length - 1;
                
                element.classList.add('flip');
                
                await sleep(baseDelay / 2);
                element.textContent = char;
                element.dataset.current = char;
                element.classList.remove('flip');
                
                const delay = isLast ? baseDelay * 2 : baseDelay + Math.min(i * 10, baseDelay);
                await sleep(delay);
            }
            
            element.classList.remove('flipping-active');
        }
        
        function getFlipSequence(from, to) {
            const fromIdx = FLAP_CHARS.indexOf(from);
            const toIdx = FLAP_CHARS.indexOf(to);
            
            if (fromIdx === -1 || toIdx === -1) return [to];
            
            const sequence = [];
            let current = fromIdx;
            
            // If same character, do a full rotation
            if (fromIdx === toIdx) {
                for (let i = 1; i <= FLAP_CHARS.length; i++) {
                    current = (fromIdx + i) % FLAP_CHARS.length;
                    sequence.push(FLAP_CHARS[current]);
                }
                return sequence;
            }
            
            // Always go forward with wrap
            while (current !== toIdx) {
                current = (current + 1) % FLAP_CHARS.length;
                sequence.push(FLAP_CHARS[current]);
            }
            
            return sequence;
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // Export/Import functions
        function exportConfig() {
            if (!config) {
                alert('No configuration loaded to export');
                return;
            }
            
            // Prepare export data
            const exportData = {
                name: config.name || 'overlay_config',
                video_transform: videoTransform,
                widgets: widgets,
                api_configs: config.api_configs || {},
                exported_at: new Date().toISOString()
            };
            
            // Create blob and download
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `overlay_config_${config.name || 'export'}_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function importConfig(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate imported data
                    if (!importedData.video_transform || !importedData.widgets) {
                        alert('Invalid configuration file format');
                        return;
                    }
                    
                    // Apply imported settings
                    videoTransform = importedData.video_transform || { x: 0, y: 0, scale: 1, rotation: 0 };
                    widgets = importedData.widgets || [];
                    
                    // Update API configs if present
                    if (importedData.api_configs && config) {
                        config.api_configs = { ...config.api_configs, ...importedData.api_configs };
                    }
                    
                    // Update UI
                    updateVideoTransform();
                    
                    // Update control values
                    document.getElementById('video-x').value = videoTransform.x;
                    document.getElementById('video-x-value').textContent = videoTransform.x;
                    document.getElementById('video-y').value = videoTransform.y;
                    document.getElementById('video-y-value').textContent = videoTransform.y;
                    document.getElementById('video-scale').value = videoTransform.scale;
                    document.getElementById('video-scale-value').textContent = videoTransform.scale;
                    document.getElementById('video-rotation').value = videoTransform.rotation;
                    document.getElementById('video-rotation-value').textContent = videoTransform.rotation;
                    
                    // Recreate widgets
                    createWidgets();
                    createVisibilityControls();
                    
                    // Restart data updates with new configs
                    startDataUpdates();
                    
                    alert('Configuration imported successfully!');
                    
                    // Optionally save to backend
                    if (confirm('Do you want to save this imported configuration?')) {
                        saveConfig(null);
                    }
                } catch (error) {
                    alert('Error importing configuration: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Clear the input so the same file can be selected again
            event.target.value = '';
        }
        
        // Initial setup
        document.getElementById('loading').textContent = 'Waiting for configuration...';
    </script>
</body>
</html>