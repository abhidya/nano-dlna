<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Projection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        body {
            background: black;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* Video container with transform capability */
        #video-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: center;
        }
        
        #bg-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Widget base styles */
        .widget {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            cursor: move;
            user-select: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: box-shadow 0.3s ease;
            overflow: visible;
        }
        
        /* Blackout overlay */
        #blackout-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: none;
        }
        
        #blackout-overlay.active {
            display: flex;
        }
        
        .light-switch {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .light-switch:hover {
            background: rgba(255, 255, 255, 0.1);
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        .light-switch svg {
            width: 24px;
            height: 24px;
            fill: rgba(255, 255, 255, 0.4);
        }
        
        .lights-widget {
            background: rgba(30, 30, 30, 0.85);
            min-width: 120px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .lights-widget:hover {
            background: rgba(40, 40, 40, 0.9);
        }
        
        .lights-widget .icon {
            width: 24px;
            height: 24px;
            fill: rgba(255, 255, 255, 0.5);
            margin-bottom: 4px;
        }
        
        .lights-widget .label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .lights-widget .widget-handle {
            display: none;
        }
        
        .widget:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        .widget.dragging {
            opacity: 0.8;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .widget-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border: 2px solid white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s;
            cursor: grab;
            z-index: 10;
        }
        
        .widget:hover .widget-handle {
            opacity: 1;
        }
        
        .widget-handle.rotate-handle {
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: #2196F3;
            cursor: crosshair;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .widget-handle.rotate-handle::after {
            content: '‚Üª';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: white;
            font-weight: bold;
        }
        
        .widget-handle.resize-se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }
        
        /* Widget specific styles */
        .weather-widget {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.9), rgba(42, 82, 152, 0.9));
        }
        
        .weather-widget h2 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 300;
        }
        
        .weather-content {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .weather-icon {
            font-size: 64px;
        }
        
        .weather-details {
            flex: 1;
        }
        
        .temperature {
            font-size: 48px;
            font-weight: 300;
            line-height: 1;
        }
        
        .weather-description {
            font-size: 18px;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .weather-location {
            font-size: 16px;
            opacity: 0.8;
            margin-top: 10px;
        }
        
        .time-widget {
            background: linear-gradient(135deg, rgba(38, 50, 56, 0.9), rgba(55, 71, 79, 0.9));
            text-align: center;
        }
        
        .time-content {
            font-size: 48px;
            font-weight: 300;
            letter-spacing: 2px;
            margin: 10px 0;
        }
        
        .date-content {
            font-size: 18px;
            opacity: 0.9;
        }
        
        .transit-widget {
            background: linear-gradient(135deg, rgba(0, 91, 149, 0.9), rgba(0, 123, 193, 0.9));
        }
        
        .transit-widget h2 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 300;
        }
        
        .transit-content {
            font-size: 18px;
            line-height: 1.6;
        }
        
        .prediction {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .prediction-route {
            font-weight: 500;
        }
        
        .prediction-time {
            color: #4CAF50;
            font-weight: 600;
        }
        
        /* Control panel */
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls.hidden {
            display: none;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 500;
            color: #4CAF50;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group input[type="number"] {
            width: 60px;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 5px;
            border-radius: 4px;
        }
        
        .control-value {
            font-size: 12px;
            opacity: 0.7;
            text-align: right;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .shortcuts {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            opacity: 0.7;
            line-height: 1.8;
        }
        
        /* Loading spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
        }
        
        /* Error state */
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5252;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading projection...</div>
    
    <div id="video-container">
        <video id="bg-video" autoplay loop muted playsinline>
            <source id="video-source" type="video/mp4"/>
            Your browser does not support the video tag.
        </video>
    </div>
    
    <div id="widgets-container"></div>
    
    <div id="blackout-overlay">
        <div class="light-switch" onclick="toggleLights()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M12 18c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-15c-3.312 0-6 2.688-6 6 0 1.408.486 2.701 1.297 3.719l4.703 5.881 4.703-5.881C17.514 11.701 18 10.408 18 9c0-3.312-2.688-6-6-6z"/>
            </svg>
        </div>
    </div>
    
    <div class="controls" id="controls">
        <h2 style="margin-bottom: 20px; font-weight: 300;">Overlay Controls</h2>
        
        <div class="control-group">
            <h3>Video Transform</h3>
            <label>X Position: <span class="control-value" id="video-x-value">0</span></label>
            <input type="range" id="video-x" min="-500" max="500" value="0">
            
            <label>Y Position: <span class="control-value" id="video-y-value">0</span></label>
            <input type="range" id="video-y" min="-500" max="500" value="0">
            
            <label>Scale: <span class="control-value" id="video-scale-value">1</span></label>
            <input type="range" id="video-scale" min="0.5" max="2" step="0.1" value="1">
            
            <label>Rotation: <span class="control-value" id="video-rotation-value">0</span>¬∞</label>
            <input type="range" id="video-rotation" min="-180" max="180" value="0">
        </div>
        
        <div class="control-group">
            <h3>Widget Visibility</h3>
            <div id="widget-visibility-controls"></div>
        </div>
        
        <div class="control-group">
            <button onclick="saveConfig(this)">üíæ Save Configuration</button>
            <button onclick="resetTransforms()">üîÑ Reset All</button>
            <button onclick="toggleControls()">üëÅÔ∏è Hide Controls</button>
        </div>
        
        <div class="control-group">
            <h3>Config Import/Export</h3>
            <button onclick="exportConfig()">üì§ Export to File</button>
            <button onclick="document.getElementById('import-file').click()">üì• Import from File</button>
            <input type="file" id="import-file" accept=".json" style="display: none;" onchange="importConfig(event)">
        </div>
        
        <div class="shortcuts">
            <strong>Keyboard Shortcuts:</strong><br>
            H: Hide/show controls<br>
            S: Save configuration<br>
            R: Reset transforms<br>
            Arrow Keys: Move selected widget<br>
            +/-: Scale selected widget<br>
            F11: Fullscreen
        </div>
    </div>
    
    <script>
        let config = null;
        let videoTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
        let widgets = [];
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let currentWidget = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStart = { width: 0, height: 0, x: 0, y: 0 };
        let rotateStart = { angle: 0, mouseAngle: 0 };
        let selectedWidget = null;
        let dataUpdateIntervals = {};
        
        // Initialize from parent window
        window.addEventListener('message', function(event) {
            if (event.data.type === 'init') {
                config = event.data.config;
                videoTransform = config.video_transform || { x: 0, y: 0, scale: 1, rotation: 0 };
                widgets = config.widgets;
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Load video with retry logic
                loadVideoWithRetry(event.data.streamingUrl);
                
                // Apply transforms
                updateVideoTransform();
                
                // Update control values to match loaded config
                document.getElementById('video-x').value = videoTransform.x;
                document.getElementById('video-x-value').textContent = videoTransform.x;
                document.getElementById('video-y').value = videoTransform.y;
                document.getElementById('video-y-value').textContent = videoTransform.y;
                document.getElementById('video-scale').value = videoTransform.scale;
                document.getElementById('video-scale-value').textContent = videoTransform.scale;
                document.getElementById('video-rotation').value = videoTransform.rotation;
                document.getElementById('video-rotation-value').textContent = videoTransform.rotation;
                
                // Create widgets
                createWidgets();
                
                // Create visibility controls
                createVisibilityControls();
                
                // Start data updates
                startDataUpdates();
            }
        });
        
        function loadVideoWithRetry(streamingUrl) {
            const video = document.getElementById('bg-video');
            const source = document.getElementById('video-source');
            
            console.log('Loading video from streaming URL:', streamingUrl);
            
            // Use the URL directly from backend
            source.src = streamingUrl;
            video.load();
            
            video.onerror = () => {
                console.error('Failed to load video from:', streamingUrl);
                showError('Unable to load video stream. Please check the streaming server is running and the video path is correct.');
            };
            
            video.oncanplay = () => {
                console.log('Video loaded successfully from:', streamingUrl);
            };
        }
        
        function showError(message) {
            const error = document.createElement('div');
            error.className = 'error';
            error.innerHTML = `<h3>Error</h3><p>${message}</p>`;
            document.body.appendChild(error);
        }
        
        function updateVideoTransform() {
            const container = document.getElementById('video-container');
            container.style.transform = `
                translate(${videoTransform.x}px, ${videoTransform.y}px)
                scale(${videoTransform.scale})
                rotate(${videoTransform.rotation}deg)
            `;
        }
        
        function createWidgets() {
            const container = document.getElementById('widgets-container');
            container.innerHTML = '';
            
            widgets.forEach(widget => {
                if (!widget.visible) return;
                
                const widgetEl = document.createElement('div');
                widgetEl.className = `widget ${widget.type}-widget`;
                widgetEl.id = widget.id;
                widgetEl.style.left = widget.position.x + 'px';
                widgetEl.style.top = widget.position.y + 'px';
                widgetEl.style.width = widget.size.width + 'px';
                widgetEl.style.height = widget.size.height + 'px';
                widgetEl.style.transform = `rotate(${widget.rotation || 0}deg)`;
                
                // Add content based on type
                if (widget.type === 'weather') {
                    widgetEl.innerHTML = `
                        <h2>Weather</h2>
                        <div class="weather-content">
                            <div class="weather-icon">‚òÄÔ∏è</div>
                            <div class="weather-details">
                                <div class="temperature">--¬∞</div>
                                <div class="weather-description">Loading...</div>
                                <div class="weather-location">--</div>
                            </div>
                        </div>
                    `;
                } else if (widget.type === 'time') {
                    widgetEl.innerHTML = `
                        <div class="time-content">00:00:00</div>
                        <div class="date-content">Loading...</div>
                    `;
                } else if (widget.type === 'transit') {
                    widgetEl.innerHTML = `
                        <h2>Transit - ${widget.config.stopName || 'Nearby Stop'}</h2>
                        <div class="transit-content">Loading predictions...</div>
                    `;
                } else if (widget.type === 'lights') {
                    widgetEl.innerHTML = `
                        <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M6 2l.01 6L10 12l-4 2.01L6.01 20C8.77 21.31 11.31 22 14 22c6.63 0 12-5.37 12-12S20.63-2 14-2C11.31-2 8.77-1.31 6 0v2z"/>
                            </svg>
                            <div class="label">Lights</div>
                        </div>
                    `;
                    widgetEl.classList.add('lights-widget');
                    widgetEl.onclick = (e) => {
                        e.stopPropagation();
                        toggleLights();
                    };
                }
                
                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'widget-handle resize-se';
                widgetEl.appendChild(resizeHandle);
                
                // Add rotation handle (except for lights widget)
                if (widget.type !== 'lights') {
                    const rotateHandle = document.createElement('div');
                    rotateHandle.className = 'widget-handle rotate-handle';
                    rotateHandle.title = 'Drag to rotate';
                    widgetEl.appendChild(rotateHandle);
                    
                    // Add event handler directly here
                    rotateHandle.addEventListener('mousedown', startRotate);
                }
                
                // Add event handlers
                widgetEl.addEventListener('mousedown', startDrag);
                resizeHandle.addEventListener('mousedown', startResize);
                widgetEl.addEventListener('click', () => selectWidget(widget.id));
                
                container.appendChild(widgetEl);
            });
        }
        
        function createVisibilityControls() {
            const container = document.getElementById('widget-visibility-controls');
            container.innerHTML = '';
            
            widgets.forEach(widget => {
                const control = document.createElement('label');
                control.style.display = 'block';
                control.style.marginBottom = '5px';
                
                // Custom label for lights widget
                const widgetLabel = widget.type === 'lights' ? 'Lights Control' : 
                                   widget.type.charAt(0).toUpperCase() + widget.type.slice(1);
                
                control.innerHTML = `
                    <input type="checkbox" ${widget.visible ? 'checked' : ''} 
                           onchange="toggleWidgetVisibility('${widget.id}', this.checked)">
                    ${widgetLabel}
                `;
                container.appendChild(control);
            });
        }
        
        function toggleWidgetVisibility(widgetId, visible) {
            const widget = widgets.find(w => w.id === widgetId);
            if (widget) {
                widget.visible = visible;
                createWidgets();
                if (visible) {
                    startDataUpdates();
                }
            }
        }
        
        function selectWidget(widgetId) {
            selectedWidget = widgetId;
            document.querySelectorAll('.widget').forEach(w => {
                w.style.border = w.id === widgetId ? '2px solid #4CAF50' : '1px solid rgba(255, 255, 255, 0.1)';
            });
            
            // Update rotation display if we have one
            const widget = widgets.find(w => w.id === widgetId);
            if (widget && window.updateSelectedWidgetInfo) {
                window.updateSelectedWidgetInfo(widget);
            }
        }
        
        function startDrag(e) {
            if (e.target.classList.contains('widget-handle')) return;
            
            isDragging = true;
            currentWidget = e.currentTarget;
            currentWidget.classList.add('dragging');
            
            const rect = currentWidget.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            selectWidget(currentWidget.id);
            e.preventDefault();
        }
        
        function startResize(e) {
            e.stopPropagation();
            isResizing = true;
            currentWidget = e.target.parentElement;
            
            const rect = currentWidget.getBoundingClientRect();
            resizeStart = {
                width: rect.width,
                height: rect.height,
                x: e.clientX,
                y: e.clientY
            };
            
            e.preventDefault();
        }
        
        function startRotate(e) {
            e.stopPropagation();
            isRotating = true;
            currentWidget = e.target.parentElement;
            
            const rect = currentWidget.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Get current rotation
            const widget = widgets.find(w => w.id === currentWidget.id);
            const currentRotation = widget.rotation || 0;
            
            // Calculate initial mouse angle
            const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
            
            rotateStart = {
                angle: currentRotation,
                mouseAngle: mouseAngle
            };
            
            e.preventDefault();
        }
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging && currentWidget) {
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                currentWidget.style.left = x + 'px';
                currentWidget.style.top = y + 'px';
                
                // Update widget position in config
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.position.x = x;
                    widget.position.y = y;
                }
            } else if (isResizing && currentWidget) {
                const deltaX = e.clientX - resizeStart.x;
                const deltaY = e.clientY - resizeStart.y;
                
                const newWidth = Math.max(200, resizeStart.width + deltaX);
                const newHeight = Math.max(100, resizeStart.height + deltaY);
                
                currentWidget.style.width = newWidth + 'px';
                currentWidget.style.height = newHeight + 'px';
                
                // Update widget size in config
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.size.width = newWidth;
                    widget.size.height = newHeight;
                }
            } else if (isRotating && currentWidget) {
                const rect = currentWidget.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Calculate current mouse angle
                const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                
                // Calculate rotation delta
                const angleDelta = currentMouseAngle - rotateStart.mouseAngle;
                let newRotation = rotateStart.angle + angleDelta;
                
                // Normalize angle to 0-360
                newRotation = ((newRotation % 360) + 360) % 360;
                
                // Apply rotation
                currentWidget.style.transform = `rotate(${newRotation}deg)`;
                
                // Update widget data
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.rotation = newRotation;
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (currentWidget) {
                currentWidget.classList.remove('dragging');
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
            currentWidget = null;
        });
        
        // Keyboard controls for fine rotation
        document.addEventListener('keydown', (e) => {
            if (selectedWidget && !e.target.matches('input')) {
                const widget = widgets.find(w => w.id === selectedWidget);
                if (!widget) return;
                
                let rotationDelta = 0;
                
                // Shift + Left/Right for rotation
                if (e.shiftKey) {
                    if (e.key === 'ArrowLeft') {
                        rotationDelta = -5;
                    } else if (e.key === 'ArrowRight') {
                        rotationDelta = 5;
                    }
                    
                    if (rotationDelta !== 0) {
                        e.preventDefault();
                        widget.rotation = ((widget.rotation || 0) + rotationDelta + 360) % 360;
                        const widgetEl = document.getElementById(widget.id);
                        if (widgetEl) {
                            widgetEl.style.transform = `rotate(${widget.rotation}deg)`;
                        }
                    }
                }
            }
        });
        
        // Video transform controls
        document.getElementById('video-x').addEventListener('input', (e) => {
            videoTransform.x = parseFloat(e.target.value);
            document.getElementById('video-x-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-y').addEventListener('input', (e) => {
            videoTransform.y = parseFloat(e.target.value);
            document.getElementById('video-y-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-scale').addEventListener('input', (e) => {
            videoTransform.scale = parseFloat(e.target.value);
            document.getElementById('video-scale-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-rotation').addEventListener('input', (e) => {
            videoTransform.rotation = parseFloat(e.target.value);
            document.getElementById('video-rotation-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        // Removed addLightsWidget function - lights widget is now added through React frontend
        
        // Lights toggle function
        function toggleLights() {
            const blackout = document.getElementById('blackout-overlay');
            const controls = document.getElementById('controls');
            const lightSwitch = blackout.querySelector('.light-switch');
            
            if (blackout.classList.contains('active')) {
                // Turn lights on
                blackout.classList.remove('active');
                controls.style.display = 'block';
            } else {
                // Turn lights off
                blackout.classList.add('active');
                controls.style.display = 'none';
                
                // Position the light switch based on the lights widget position
                const lightsWidget = widgets.find(w => w.type === 'lights' && w.visible);
                if (lightsWidget) {
                    lightSwitch.style.position = 'absolute';
                    lightSwitch.style.left = lightsWidget.position.x + 'px';
                    lightSwitch.style.top = lightsWidget.position.y + 'px';
                }
            }
        }
        
        // Control functions
        function saveConfig(button) {
            if (!config) return;
            
            config.video_transform = videoTransform;
            config.widgets = widgets;
            
            if (window.opener && !window.opener.closed) {
                window.opener.postMessage({
                    type: 'updateConfig',
                    config: config
                }, '*');
                
                // Visual feedback
                if (button) {
                    button.textContent = '‚úÖ Saved!';
                    setTimeout(() => {
                        button.textContent = 'üíæ Save Configuration';
                    }, 2000);
                }
            }
        }
        
        function resetTransforms() {
            videoTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
            
            // Reset controls
            document.getElementById('video-x').value = 0;
            document.getElementById('video-x-value').textContent = '0';
            document.getElementById('video-y').value = 0;
            document.getElementById('video-y-value').textContent = '0';
            document.getElementById('video-scale').value = 1;
            document.getElementById('video-scale-value').textContent = '1';
            document.getElementById('video-rotation').value = 0;
            document.getElementById('video-rotation-value').textContent = '0';
            
            updateVideoTransform();
        }
        
        function toggleControls() {
            document.getElementById('controls').classList.toggle('hidden');
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const step = e.shiftKey ? 10 : 1;
            
            if (e.key === 'h' || e.key === 'H') {
                toggleControls();
            } else if (e.key === 's' || e.key === 'S') {
                saveConfig(null);
            } else if (e.key === 'r' || e.key === 'R') {
                resetTransforms();
            } else if (e.key === 'F11') {
                e.preventDefault();
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            } else if (selectedWidget) {
                // Widget movement with arrow keys
                const widget = widgets.find(w => w.id === selectedWidget);
                const widgetEl = document.getElementById(selectedWidget);
                
                if (widget && widgetEl) {
                    switch(e.key) {
                        case 'ArrowLeft':
                            widget.position.x -= step;
                            widgetEl.style.left = widget.position.x + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            widget.position.x += step;
                            widgetEl.style.left = widget.position.x + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowUp':
                            widget.position.y -= step;
                            widgetEl.style.top = widget.position.y + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            widget.position.y += step;
                            widgetEl.style.top = widget.position.y + 'px';
                            e.preventDefault();
                            break;
                    }
                }
            }
        });
        
        // Data update functions
        function startDataUpdates() {
            // Clear existing intervals
            Object.values(dataUpdateIntervals).forEach(interval => clearInterval(interval));
            dataUpdateIntervals = {};
            
            // Update time immediately and every second
            updateTime();
            dataUpdateIntervals.time = setInterval(updateTime, 1000);
            
            // Update weather immediately and every 5 minutes
            updateWeather();
            dataUpdateIntervals.weather = setInterval(updateWeather, 300000);
            
            // Update transit immediately and every minute
            updateTransit();
            dataUpdateIntervals.transit = setInterval(updateTransit, 60000);
        }
        
        function updateTime() {
            const timeWidgets = document.querySelectorAll('.time-widget');
            const now = new Date();
            
            const timeString = now.toLocaleTimeString('en-US', { 
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            const dateString = now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            timeWidgets.forEach(widget => {
                const timeEl = widget.querySelector('.time-content');
                const dateEl = widget.querySelector('.date-content');
                if (timeEl) timeEl.textContent = timeString;
                if (dateEl) dateEl.textContent = dateString;
            });
        }
        
        async function updateWeather() {
            if (!config?.api_configs?.weather_api_key) {
                console.warn('No weather API key configured');
                return;
            }
            
            const weatherWidgets = document.querySelectorAll('.weather-widget');
            if (weatherWidgets.length === 0) return;
            
            try {
                // Get location
                const locationResponse = await fetch('https://ipinfo.io/json');
                const locationData = await locationResponse.json();
                const city = locationData.city || 'San Francisco';
                
                // Get weather
                const weatherResponse = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${config.api_configs.weather_api_key}&units=metric`
                );
                const weatherData = await weatherResponse.json();
                
                // Map weather conditions to emojis
                const weatherIcons = {
                    'Clear': '‚òÄÔ∏è',
                    'Clouds': '‚òÅÔ∏è',
                    'Rain': 'üåßÔ∏è',
                    'Drizzle': 'üå¶Ô∏è',
                    'Thunderstorm': '‚õàÔ∏è',
                    'Snow': '‚ùÑÔ∏è',
                    'Mist': 'üå´Ô∏è',
                    'Fog': 'üå´Ô∏è'
                };
                
                const icon = weatherIcons[weatherData.weather[0].main] || 'üå°Ô∏è';
                const temp = Math.round(weatherData.main.temp);
                const description = weatherData.weather[0].description;
                const location = weatherData.name;
                
                weatherWidgets.forEach(widget => {
                    widget.querySelector('.weather-icon').textContent = icon;
                    widget.querySelector('.temperature').textContent = `${temp}¬∞`;
                    widget.querySelector('.weather-description').textContent = description;
                    widget.querySelector('.weather-location').textContent = location;
                });
            } catch (error) {
                console.error('Weather update error:', error);
                weatherWidgets.forEach(widget => {
                    widget.querySelector('.weather-description').textContent = 'Weather unavailable';
                });
            }
        }
        
        async function updateTransit() {
            if (!config?.api_configs?.transit_stop_id) {
                console.warn('No transit stop ID configured');
                return;
            }
            
            const transitWidgets = document.querySelectorAll('.transit-widget');
            if (transitWidgets.length === 0) return;
            
            try {
                const response = await fetch(
                    `https://webservices.umoiq.com/api/pub/v1/agencies/sfmta-cis/stopcodes/${config.api_configs.transit_stop_id}/predictions?key=0be8ebd0284ce712a63f29dcaf7798c4`
                );
                const data = await response.json();
                
                transitWidgets.forEach(widget => {
                    const widgetConfig = widgets.find(w => w.id === widget.id);
                    const routeFilter = widgetConfig?.config?.routeFilter?.toLowerCase();
                    
                    // Filter predictions
                    let predictions = data;
                    if (routeFilter) {
                        predictions = data.filter(p => 
                            p.route.title.toLowerCase().includes(routeFilter)
                        );
                    }
                    
                    const content = widget.querySelector('.transit-content');
                    
                    if (predictions.length === 0) {
                        content.innerHTML = 'No predictions available';
                        return;
                    }
                    
                    // Show up to 3 predictions
                    const html = predictions.slice(0, 3).map(prediction => {
                        const minutes = prediction.values[0]?.minutes || 'N/A';
                        return `
                            <div class="prediction">
                                <span class="prediction-route">${prediction.route.title}</span>
                                <span class="prediction-time">${minutes} min</span>
                            </div>
                        `;
                    }).join('');
                    
                    content.innerHTML = html;
                });
            } catch (error) {
                console.error('Transit update error:', error);
                transitWidgets.forEach(widget => {
                    widget.querySelector('.transit-content').innerHTML = 'Transit data unavailable';
                });
            }
        }
        
        // Export/Import functions
        function exportConfig() {
            if (!config) {
                alert('No configuration loaded to export');
                return;
            }
            
            // Prepare export data
            const exportData = {
                name: config.name || 'overlay_config',
                video_transform: videoTransform,
                widgets: widgets,
                api_configs: config.api_configs || {},
                exported_at: new Date().toISOString()
            };
            
            // Create blob and download
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `overlay_config_${config.name || 'export'}_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function importConfig(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate imported data
                    if (!importedData.video_transform || !importedData.widgets) {
                        alert('Invalid configuration file format');
                        return;
                    }
                    
                    // Apply imported settings
                    videoTransform = importedData.video_transform || { x: 0, y: 0, scale: 1, rotation: 0 };
                    widgets = importedData.widgets || [];
                    
                    // Update API configs if present
                    if (importedData.api_configs && config) {
                        config.api_configs = { ...config.api_configs, ...importedData.api_configs };
                    }
                    
                    // Update UI
                    updateVideoTransform();
                    
                    // Update control values
                    document.getElementById('video-x').value = videoTransform.x;
                    document.getElementById('video-x-value').textContent = videoTransform.x;
                    document.getElementById('video-y').value = videoTransform.y;
                    document.getElementById('video-y-value').textContent = videoTransform.y;
                    document.getElementById('video-scale').value = videoTransform.scale;
                    document.getElementById('video-scale-value').textContent = videoTransform.scale;
                    document.getElementById('video-rotation').value = videoTransform.rotation;
                    document.getElementById('video-rotation-value').textContent = videoTransform.rotation;
                    
                    // Recreate widgets
                    createWidgets();
                    createVisibilityControls();
                    
                    // Restart data updates with new configs
                    startDataUpdates();
                    
                    alert('Configuration imported successfully!');
                    
                    // Optionally save to backend
                    if (confirm('Do you want to save this imported configuration?')) {
                        saveConfig(null);
                    }
                } catch (error) {
                    alert('Error importing configuration: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Clear the input so the same file can be selected again
            event.target.value = '';
        }
        
        // Initial setup
        document.getElementById('loading').textContent = 'Waiting for configuration...';
    </script>
</body>
</html>