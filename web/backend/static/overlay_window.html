<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Projection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        body {
            background: black;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* Video container with transform capability */
        #video-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: center;
        }
        
        #bg-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Widget base styles */
        .widget {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            cursor: move;
            user-select: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: box-shadow 0.3s ease;
        }
        
        .widget:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        .widget.dragging {
            opacity: 0.8;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .widget-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border: 2px solid white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .widget:hover .widget-handle {
            opacity: 1;
        }
        
        .widget-handle.resize-se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }
        
        /* Widget specific styles */
        .weather-widget {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.9), rgba(42, 82, 152, 0.9));
        }
        
        .weather-widget h2 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 300;
        }
        
        .weather-content {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .weather-icon {
            font-size: 64px;
        }
        
        .weather-details {
            flex: 1;
        }
        
        .temperature {
            font-size: 48px;
            font-weight: 300;
            line-height: 1;
        }
        
        .weather-description {
            font-size: 18px;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .weather-location {
            font-size: 16px;
            opacity: 0.8;
            margin-top: 10px;
        }
        
        .time-widget {
            background: linear-gradient(135deg, rgba(38, 50, 56, 0.9), rgba(55, 71, 79, 0.9));
            text-align: center;
        }
        
        .time-content {
            font-size: 48px;
            font-weight: 300;
            letter-spacing: 2px;
            margin: 10px 0;
        }
        
        .date-content {
            font-size: 18px;
            opacity: 0.9;
        }
        
        .transit-widget {
            background: linear-gradient(135deg, rgba(0, 91, 149, 0.9), rgba(0, 123, 193, 0.9));
        }
        
        .transit-widget h2 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 300;
        }
        
        .transit-content {
            font-size: 18px;
            line-height: 1.6;
        }
        
        .prediction {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .prediction-route {
            font-weight: 500;
        }
        
        .prediction-time {
            color: #4CAF50;
            font-weight: 600;
        }
        
        /* Control panel */
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls.hidden {
            display: none;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 500;
            color: #4CAF50;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group input[type="number"] {
            width: 60px;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 5px;
            border-radius: 4px;
        }
        
        .control-value {
            font-size: 12px;
            opacity: 0.7;
            text-align: right;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .shortcuts {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            opacity: 0.7;
            line-height: 1.8;
        }
        
        /* Loading spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
        }
        
        /* Error state */
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5252;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading projection...</div>
    
    <div id="video-container">
        <video id="bg-video" autoplay loop muted playsinline>
            <source id="video-source" type="video/mp4"/>
            Your browser does not support the video tag.
        </video>
    </div>
    
    <div id="widgets-container"></div>
    
    <div class="controls" id="controls">
        <h2 style="margin-bottom: 20px; font-weight: 300;">Overlay Controls</h2>
        
        <div class="control-group">
            <h3>Video Transform</h3>
            <label>X Position: <span class="control-value" id="video-x-value">0</span></label>
            <input type="range" id="video-x" min="-500" max="500" value="0">
            
            <label>Y Position: <span class="control-value" id="video-y-value">0</span></label>
            <input type="range" id="video-y" min="-500" max="500" value="0">
            
            <label>Scale: <span class="control-value" id="video-scale-value">1</span></label>
            <input type="range" id="video-scale" min="0.5" max="2" step="0.1" value="1">
            
            <label>Rotation: <span class="control-value" id="video-rotation-value">0</span>¬∞</label>
            <input type="range" id="video-rotation" min="-180" max="180" value="0">
        </div>
        
        <div class="control-group">
            <h3>Widget Visibility</h3>
            <div id="widget-visibility-controls"></div>
        </div>
        
        <div class="control-group">
            <button onclick="saveConfig()">üíæ Save Configuration</button>
            <button onclick="resetTransforms()">üîÑ Reset All</button>
            <button onclick="toggleControls()">üëÅÔ∏è Hide Controls</button>
        </div>
        
        <div class="shortcuts">
            <strong>Keyboard Shortcuts:</strong><br>
            H: Hide/show controls<br>
            S: Save configuration<br>
            R: Reset transforms<br>
            Arrow Keys: Move selected widget<br>
            +/-: Scale selected widget<br>
            F11: Fullscreen
        </div>
    </div>
    
    <script>
        let config = null;
        let videoTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
        let widgets = [];
        let isDragging = false;
        let isResizing = false;
        let currentWidget = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStart = { width: 0, height: 0, x: 0, y: 0 };
        let selectedWidget = null;
        let dataUpdateIntervals = {};
        
        // Initialize from parent window
        window.addEventListener('message', function(event) {
            if (event.data.type === 'init') {
                config = event.data.config;
                videoTransform = config.video_transform;
                widgets = config.widgets;
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Load video with retry logic
                loadVideoWithRetry(event.data.streamingUrl);
                
                // Apply transforms
                updateVideoTransform();
                
                // Create widgets
                createWidgets();
                
                // Create visibility controls
                createVisibilityControls();
                
                // Start data updates
                startDataUpdates();
            }
        });
        
        function loadVideoWithRetry(baseUrl) {
            const video = document.getElementById('bg-video');
            const source = document.getElementById('video-source');
            
            // Extract base URL and filename
            const urlParts = baseUrl.split('/');
            const filename = urlParts.pop();
            const baseUrlWithoutFile = urlParts.slice(0, -1).join('/');
            
            // Try different ports
            let currentPort = 9000;
            const maxPort = 9010;
            let attempts = 0;
            
            function tryNextPort() {
                if (currentPort > maxPort) {
                    showError('Unable to load video stream. Please check streaming server.');
                    return;
                }
                
                const url = baseUrlWithoutFile.replace(/:\d+/, `:${currentPort}`) + '/' + filename;
                console.log('Trying video URL:', url);
                
                source.src = url;
                video.load();
                
                video.onerror = () => {
                    console.error('Failed to load video on port', currentPort);
                    currentPort++;
                    setTimeout(tryNextPort, 500);
                };
                
                video.oncanplay = () => {
                    console.log('Video loaded successfully from:', url);
                };
            }
            
            tryNextPort();
        }
        
        function showError(message) {
            const error = document.createElement('div');
            error.className = 'error';
            error.innerHTML = `<h3>Error</h3><p>${message}</p>`;
            document.body.appendChild(error);
        }
        
        function updateVideoTransform() {
            const container = document.getElementById('video-container');
            container.style.transform = `
                translate(${videoTransform.x}px, ${videoTransform.y}px)
                scale(${videoTransform.scale})
                rotate(${videoTransform.rotation}deg)
            `;
        }
        
        function createWidgets() {
            const container = document.getElementById('widgets-container');
            container.innerHTML = '';
            
            widgets.forEach(widget => {
                if (!widget.visible) return;
                
                const widgetEl = document.createElement('div');
                widgetEl.className = `widget ${widget.type}-widget`;
                widgetEl.id = widget.id;
                widgetEl.style.left = widget.position.x + 'px';
                widgetEl.style.top = widget.position.y + 'px';
                widgetEl.style.width = widget.size.width + 'px';
                widgetEl.style.height = widget.size.height + 'px';
                
                // Add content based on type
                if (widget.type === 'weather') {
                    widgetEl.innerHTML = `
                        <h2>Weather</h2>
                        <div class="weather-content">
                            <div class="weather-icon">‚òÄÔ∏è</div>
                            <div class="weather-details">
                                <div class="temperature">--¬∞</div>
                                <div class="weather-description">Loading...</div>
                                <div class="weather-location">--</div>
                            </div>
                        </div>
                    `;
                } else if (widget.type === 'time') {
                    widgetEl.innerHTML = `
                        <div class="time-content">00:00:00</div>
                        <div class="date-content">Loading...</div>
                    `;
                } else if (widget.type === 'transit') {
                    widgetEl.innerHTML = `
                        <h2>Transit - ${widget.config.stopName || 'Nearby Stop'}</h2>
                        <div class="transit-content">Loading predictions...</div>
                    `;
                }
                
                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'widget-handle resize-se';
                widgetEl.appendChild(resizeHandle);
                
                // Add event handlers
                widgetEl.addEventListener('mousedown', startDrag);
                resizeHandle.addEventListener('mousedown', startResize);
                widgetEl.addEventListener('click', () => selectWidget(widget.id));
                
                container.appendChild(widgetEl);
            });
        }
        
        function createVisibilityControls() {
            const container = document.getElementById('widget-visibility-controls');
            container.innerHTML = '';
            
            widgets.forEach(widget => {
                const control = document.createElement('label');
                control.style.display = 'block';
                control.style.marginBottom = '5px';
                control.innerHTML = `
                    <input type="checkbox" ${widget.visible ? 'checked' : ''} 
                           onchange="toggleWidgetVisibility('${widget.id}', this.checked)">
                    ${widget.type.charAt(0).toUpperCase() + widget.type.slice(1)}
                `;
                container.appendChild(control);
            });
        }
        
        function toggleWidgetVisibility(widgetId, visible) {
            const widget = widgets.find(w => w.id === widgetId);
            if (widget) {
                widget.visible = visible;
                createWidgets();
                if (visible) {
                    startDataUpdates();
                }
            }
        }
        
        function selectWidget(widgetId) {
            selectedWidget = widgetId;
            document.querySelectorAll('.widget').forEach(w => {
                w.style.border = w.id === widgetId ? '2px solid #4CAF50' : '1px solid rgba(255, 255, 255, 0.1)';
            });
        }
        
        function startDrag(e) {
            if (e.target.classList.contains('widget-handle')) return;
            
            isDragging = true;
            currentWidget = e.currentTarget;
            currentWidget.classList.add('dragging');
            
            const rect = currentWidget.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            selectWidget(currentWidget.id);
            e.preventDefault();
        }
        
        function startResize(e) {
            e.stopPropagation();
            isResizing = true;
            currentWidget = e.target.parentElement;
            
            const rect = currentWidget.getBoundingClientRect();
            resizeStart = {
                width: rect.width,
                height: rect.height,
                x: e.clientX,
                y: e.clientY
            };
            
            e.preventDefault();
        }
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging && currentWidget) {
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                currentWidget.style.left = x + 'px';
                currentWidget.style.top = y + 'px';
                
                // Update widget position in config
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.position.x = x;
                    widget.position.y = y;
                }
            } else if (isResizing && currentWidget) {
                const deltaX = e.clientX - resizeStart.x;
                const deltaY = e.clientY - resizeStart.y;
                
                const newWidth = Math.max(200, resizeStart.width + deltaX);
                const newHeight = Math.max(100, resizeStart.height + deltaY);
                
                currentWidget.style.width = newWidth + 'px';
                currentWidget.style.height = newHeight + 'px';
                
                // Update widget size in config
                const widget = widgets.find(w => w.id === currentWidget.id);
                if (widget) {
                    widget.size.width = newWidth;
                    widget.size.height = newHeight;
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (currentWidget) {
                currentWidget.classList.remove('dragging');
            }
            isDragging = false;
            isResizing = false;
            currentWidget = null;
        });
        
        // Video transform controls
        document.getElementById('video-x').addEventListener('input', (e) => {
            videoTransform.x = parseFloat(e.target.value);
            document.getElementById('video-x-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-y').addEventListener('input', (e) => {
            videoTransform.y = parseFloat(e.target.value);
            document.getElementById('video-y-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-scale').addEventListener('input', (e) => {
            videoTransform.scale = parseFloat(e.target.value);
            document.getElementById('video-scale-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        document.getElementById('video-rotation').addEventListener('input', (e) => {
            videoTransform.rotation = parseFloat(e.target.value);
            document.getElementById('video-rotation-value').textContent = e.target.value;
            updateVideoTransform();
        });
        
        // Control functions
        function saveConfig() {
            if (!config) return;
            
            config.video_transform = videoTransform;
            config.widgets = widgets;
            
            if (window.opener && !window.opener.closed) {
                window.opener.postMessage({
                    type: 'updateConfig',
                    config: config
                }, '*');
                
                // Visual feedback
                const button = event.target;
                button.textContent = '‚úÖ Saved!';
                setTimeout(() => {
                    button.textContent = 'üíæ Save Configuration';
                }, 2000);
            }
        }
        
        function resetTransforms() {
            videoTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
            
            // Reset controls
            document.getElementById('video-x').value = 0;
            document.getElementById('video-x-value').textContent = '0';
            document.getElementById('video-y').value = 0;
            document.getElementById('video-y-value').textContent = '0';
            document.getElementById('video-scale').value = 1;
            document.getElementById('video-scale-value').textContent = '1';
            document.getElementById('video-rotation').value = 0;
            document.getElementById('video-rotation-value').textContent = '0';
            
            updateVideoTransform();
        }
        
        function toggleControls() {
            document.getElementById('controls').classList.toggle('hidden');
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const step = e.shiftKey ? 10 : 1;
            
            if (e.key === 'h' || e.key === 'H') {
                toggleControls();
            } else if (e.key === 's' || e.key === 'S') {
                saveConfig();
            } else if (e.key === 'r' || e.key === 'R') {
                resetTransforms();
            } else if (e.key === 'F11') {
                e.preventDefault();
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            } else if (selectedWidget) {
                // Widget movement with arrow keys
                const widget = widgets.find(w => w.id === selectedWidget);
                const widgetEl = document.getElementById(selectedWidget);
                
                if (widget && widgetEl) {
                    switch(e.key) {
                        case 'ArrowLeft':
                            widget.position.x -= step;
                            widgetEl.style.left = widget.position.x + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            widget.position.x += step;
                            widgetEl.style.left = widget.position.x + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowUp':
                            widget.position.y -= step;
                            widgetEl.style.top = widget.position.y + 'px';
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            widget.position.y += step;
                            widgetEl.style.top = widget.position.y + 'px';
                            e.preventDefault();
                            break;
                    }
                }
            }
        });
        
        // Data update functions
        function startDataUpdates() {
            // Clear existing intervals
            Object.values(dataUpdateIntervals).forEach(interval => clearInterval(interval));
            dataUpdateIntervals = {};
            
            // Update time immediately and every second
            updateTime();
            dataUpdateIntervals.time = setInterval(updateTime, 1000);
            
            // Update weather immediately and every 5 minutes
            updateWeather();
            dataUpdateIntervals.weather = setInterval(updateWeather, 300000);
            
            // Update transit immediately and every minute
            updateTransit();
            dataUpdateIntervals.transit = setInterval(updateTransit, 60000);
        }
        
        function updateTime() {
            const timeWidgets = document.querySelectorAll('.time-widget');
            const now = new Date();
            
            const timeString = now.toLocaleTimeString('en-US', { 
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            const dateString = now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            timeWidgets.forEach(widget => {
                const timeEl = widget.querySelector('.time-content');
                const dateEl = widget.querySelector('.date-content');
                if (timeEl) timeEl.textContent = timeString;
                if (dateEl) dateEl.textContent = dateString;
            });
        }
        
        async function updateWeather() {
            if (!config?.api_configs?.weather_api_key) {
                console.warn('No weather API key configured');
                return;
            }
            
            const weatherWidgets = document.querySelectorAll('.weather-widget');
            if (weatherWidgets.length === 0) return;
            
            try {
                // Get location
                const locationResponse = await fetch('https://ipinfo.io/json');
                const locationData = await locationResponse.json();
                const city = locationData.city || 'San Francisco';
                
                // Get weather
                const weatherResponse = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${config.api_configs.weather_api_key}&units=metric`
                );
                const weatherData = await weatherResponse.json();
                
                // Map weather conditions to emojis
                const weatherIcons = {
                    'Clear': '‚òÄÔ∏è',
                    'Clouds': '‚òÅÔ∏è',
                    'Rain': 'üåßÔ∏è',
                    'Drizzle': 'üå¶Ô∏è',
                    'Thunderstorm': '‚õàÔ∏è',
                    'Snow': '‚ùÑÔ∏è',
                    'Mist': 'üå´Ô∏è',
                    'Fog': 'üå´Ô∏è'
                };
                
                const icon = weatherIcons[weatherData.weather[0].main] || 'üå°Ô∏è';
                const temp = Math.round(weatherData.main.temp);
                const description = weatherData.weather[0].description;
                const location = weatherData.name;
                
                weatherWidgets.forEach(widget => {
                    widget.querySelector('.weather-icon').textContent = icon;
                    widget.querySelector('.temperature').textContent = `${temp}¬∞`;
                    widget.querySelector('.weather-description').textContent = description;
                    widget.querySelector('.weather-location').textContent = location;
                });
            } catch (error) {
                console.error('Weather update error:', error);
                weatherWidgets.forEach(widget => {
                    widget.querySelector('.weather-description').textContent = 'Weather unavailable';
                });
            }
        }
        
        async function updateTransit() {
            if (!config?.api_configs?.transit_stop_id) {
                console.warn('No transit stop ID configured');
                return;
            }
            
            const transitWidgets = document.querySelectorAll('.transit-widget');
            if (transitWidgets.length === 0) return;
            
            try {
                const response = await fetch(
                    `https://webservices.umoiq.com/api/pub/v1/agencies/sfmta-cis/stopcodes/${config.api_configs.transit_stop_id}/predictions?key=0be8ebd0284ce712a63f29dcaf7798c4`
                );
                const data = await response.json();
                
                transitWidgets.forEach(widget => {
                    const widgetConfig = widgets.find(w => w.id === widget.id);
                    const routeFilter = widgetConfig?.config?.routeFilter?.toLowerCase();
                    
                    // Filter predictions
                    let predictions = data;
                    if (routeFilter) {
                        predictions = data.filter(p => 
                            p.route.title.toLowerCase().includes(routeFilter)
                        );
                    }
                    
                    const content = widget.querySelector('.transit-content');
                    
                    if (predictions.length === 0) {
                        content.innerHTML = 'No predictions available';
                        return;
                    }
                    
                    // Show up to 3 predictions
                    const html = predictions.slice(0, 3).map(prediction => {
                        const minutes = prediction.values[0]?.minutes || 'N/A';
                        return `
                            <div class="prediction">
                                <span class="prediction-route">${prediction.route.title}</span>
                                <span class="prediction-time">${minutes} min</span>
                            </div>
                        `;
                    }).join('');
                    
                    content.innerHTML = html;
                });
            } catch (error) {
                console.error('Transit update error:', error);
                transitWidgets.forEach(widget => {
                    widget.querySelector('.transit-content').innerHTML = 'Transit data unavailable';
                });
            }
        }
        
        // Initial setup
        document.getElementById('loading').textContent = 'Waiting for configuration...';
    </script>
</body>
</html>